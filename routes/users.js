const express = require('express');
const router = express.Router();
const auth = require('../middlewares/auth');
const User = require('../models/User');
const bcrypt = require('bcryptjs');

// Imports des mod√®les pour la suppression CASCADE RGPD
const ObjectModel = require('../models/Object');
const Trade = require('../models/Trade');
const Message = require('../models/Message');
const Notification = require('../models/Notification');
const SecurityLog = require('../models/SecurityLog');
const PaymentMethod = require('../models/PaymentMethod');
const Advertisement = require('../models/Advertisement');

// --- Pr√©f√©rences de notification ---
// GET /me/notification-preferences
router.get('/me/notification-preferences', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('notificationPreferences');
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©.' });
    res.json({ notificationPreferences: user.notificationPreferences });
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// PUT /me/notification-preferences
router.put('/me/notification-preferences', auth, async (req, res) => {
  const allowedFields = ['notifications_push', 'notifications_email', 'promotions', 'sound', 'vibration'];
  const updates = {};
  for (const key of allowedFields) {
    if (typeof req.body[key] === 'boolean') {
      updates[`notificationPreferences.${key}`] = req.body[key];
    }
  }
  if (Object.keys(updates).length === 0) {
    return res.status(400).json({ message: 'Aucune pr√©f√©rence valide fournie.' });
  }
  try {
    const user = await User.findByIdAndUpdate(
      req.user.id,
      { $set: updates },
      { new: true, select: 'notificationPreferences' }
    );
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©.' });
    res.json({ notificationPreferences: user.notificationPreferences });
  } catch (err) {
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// --- Pr√©f√©rences de fonctionnalit√©s ---
// GET /me/preferences - R√©cup√©rer les pr√©f√©rences de fonctionnalit√©s
router.get('/me/preferences', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('featurePreferences');
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©.' });
    
    // Mapper les pr√©f√©rences pour l'interface mobile
    const preferences = {
      detailedAnalytics: user.featurePreferences?.analytics ?? true,
      pushNotifications: user.featurePreferences?.notifications ?? true,
      geolocation: true, // Toujours activ√© pour l'instant
      ecoImpact: user.featurePreferences?.eco ?? true,
      gamification: user.featurePreferences?.gaming ?? true
    };
    
    res.json({ success: true, preferences });
  } catch (err) {
    console.error('Erreur r√©cup√©ration pr√©f√©rences:', err);
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

// PUT /me/preferences - Mettre √† jour les pr√©f√©rences de fonctionnalit√©s  
router.put('/me/preferences', auth, async (req, res) => {
  try {
    const updates = {};
    
    // Mapper les pr√©f√©rences de l'interface vers le mod√®le
    if (typeof req.body.detailedAnalytics !== 'undefined') {
      updates['featurePreferences.analytics'] = req.body.detailedAnalytics;
    }
    if (typeof req.body.pushNotifications !== 'undefined') {
      updates['featurePreferences.notifications'] = req.body.pushNotifications;
    }
    if (typeof req.body.ecoImpact !== 'undefined') {
      updates['featurePreferences.eco'] = req.body.ecoImpact;
    }
    if (typeof req.body.gamification !== 'undefined') {
      updates['featurePreferences.gaming'] = req.body.gamification;
    }

    const user = await User.findByIdAndUpdate(
      req.user.id,
      { $set: updates },
      { new: true, select: 'featurePreferences' }
    );
    
    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©.' });
    
    // Retourner les pr√©f√©rences dans le format attendu
    const preferences = {
      detailedAnalytics: user.featurePreferences?.analytics ?? true,
      pushNotifications: user.featurePreferences?.notifications ?? true,
      geolocation: true,
      ecoImpact: user.featurePreferences?.eco ?? true,
      gamification: user.featurePreferences?.gaming ?? true
    };
    
    res.json({ success: true, preferences });
  } catch (err) {
    console.error('Erreur mise √† jour pr√©f√©rences:', err);
    res.status(500).json({ message: 'Erreur serveur.' });
  }
});

const Category = require('../models/Category'); // Assurez-vous d'importer le mod√®le Category

const MIN_CATEGORY_COUNT = 4;
const MAX_CATEGORY_COUNT = 8; // Modifiez ce nombre selon la limite souhait√©e

// GET /:id - R√©cup√©rer le profil public d'un utilisateur
router.get('/:id', async (req, res) => {
  try {
    const userId = req.params.id;
    
    console.log('üîç [DEBUG] R√©cup√©ration profil pour userId:', userId);
    
    // Validation de l'ID utilisateur
    if (!userId || userId === 'undefined' || userId === 'null') {
      console.log('‚ùå [DEBUG] ID utilisateur invalide:', userId);
      return res.status(400).json({ 
        success: false, 
        message: "ID utilisateur manquant ou invalide." 
      });
    }

    // V√©rifier que l'ID est un ObjectId valide
    const mongoose = require('mongoose');
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      console.log('‚ùå [DEBUG] Format ObjectId invalide:', userId);
      return res.status(400).json({ 
        success: false, 
        message: "Format d'ID utilisateur invalide." 
      });
    }

    // R√©cup√©rer le profil utilisateur (champs publics uniquement)
    const user = await User.findById(userId)
      .select('pseudo avatar city verified createdAt profile tradeStats subscriptionPlan')
      .lean();
    
    if (!user) {
      console.log('‚ùå [DEBUG] Utilisateur non trouv√©:', userId);
      return res.status(404).json({ 
        success: false, 
        message: 'Utilisateur introuvable.' 
      });
    }

    console.log('‚úÖ [DEBUG] Profil utilisateur trouv√©:', user.pseudo);

    // Calculer les statistiques d'√©changes
    const ObjectModel = require('../models/Object');
    const Trade = require('../models/Trade');
    
    // Compter les objets disponibles de l'utilisateur
    const objectsCount = await ObjectModel.countDocuments({ 
      owner: userId, 
      status: 'available' 
    });

    // Compter les √©changes termin√©s
    const completedTrades = await Trade.countDocuments({
      $and: [
        { status: 'completed' },
        {
          $or: [
            { fromUser: userId },
            { toUser: userId }
          ]
        }
      ]
    });

    // Calculer la note moyenne depuis les √©changes
    const tradesWithRatings = await Trade.find({
      $and: [
        { status: 'completed' },
        { 
          $or: [
            { fromUser: userId, 'ratings.toUserRating': { $exists: true } },
            { toUser: userId, 'ratings.fromUserRating': { $exists: true } }
          ]
        }
      ]
    }).select('ratings fromUser toUser');

    let totalRating = 0;
    let ratingCount = 0;

    tradesWithRatings.forEach(trade => {
      if (trade.fromUser.toString() === userId && trade.ratings?.toUserRating?.score) {
        totalRating += trade.ratings.toUserRating.score;
        ratingCount++;
      }
      if (trade.toUser.toString() === userId && trade.ratings?.fromUserRating?.score) {
        totalRating += trade.ratings.fromUserRating.score;
        ratingCount++;
      }
    });

    const averageRating = ratingCount > 0 ? Math.round((totalRating / ratingCount) * 10) / 10 : 0;

    // Construire le profil public enrichi
    const publicProfile = {
      _id: user._id,
      pseudo: user.pseudo,
      avatar: user.avatar,
      city: user.city,
      verified: user.verified,
      joinedAt: user.createdAt,
      profile: user.profile || {},
      stats: {
        objectsCount,
        completedTrades,
        averageRating,
        totalRatings: ratingCount
      },
      subscriptionPlan: user.subscriptionPlan,
      // Calculer un score de confiance bas√© sur l'activit√© et les √©valuations
      trustScore: Math.min(100, Math.round(
        (completedTrades * 10) + 
        (averageRating * 15) + 
        (user.verified ? 20 : 0) +
        (objectsCount * 2)
      ))
    };

    console.log('‚úÖ [DEBUG] Profil public construit:', {
      pseudo: publicProfile.pseudo,
      objectsCount,
      completedTrades,
      averageRating,
      trustScore: publicProfile.trustScore
    });

    res.json({
      success: true,
      user: publicProfile
    });

  } catch (err) {
    console.error('‚ùå [DEBUG] Erreur r√©cup√©ration profil:', err);
    res.status(500).json({ 
      success: false, 
      message: "Erreur serveur lors de la r√©cup√©ration du profil." 
    });
  }
});

router.post('/me/favorites', auth, async (req, res) => {
  const { categories } = req.body;
  if (!Array.isArray(categories) || categories.length < MIN_CATEGORY_COUNT || categories.length > MAX_CATEGORY_COUNT) {
    return res.status(400).json({ message: `Vous devez s√©lectionner entre ${MIN_CATEGORY_COUNT} et ${MAX_CATEGORY_COUNT} cat√©gories.` });
  }
  // V√©rifie que toutes les cat√©gories existent
  try {
    const found = await Category.find({ _id: { $in: categories } });
    if (found.length < MIN_CATEGORY_COUNT || found.length !== categories.length) {
      return res.status(400).json({ message: "Une ou plusieurs cat√©gories sont invalides." });
    }
    const user = await User.findByIdAndUpdate(req.user.id, { favoriteCategories: categories }, { new: true });
    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©." });
    }
    res.json({ favoriteCategories: user.favoriteCategories });
  } catch (err) {
    res.status(500).json({ message: "Erreur serveur." });
  }
});

router.get('/me/favorites', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .populate('favoriteCategories', 'name fields')
      .select('favoriteCategories');
    if (!user) {
      return res.status(404).json({ message: "Utilisateur non trouv√©." });
    }
    res.json({ favoriteCategories: user.favoriteCategories });
  } catch (err) {
    res.status(500).json({ message: "Erreur serveur." });
  }
});

/**
 * POST /api/users/me/favorite-objects/:objectId
 * Ajouter/retirer un objet des favoris
 */
router.post('/me/favorite-objects/:objectId', auth, async (req, res) => {
  try {
    const { objectId } = req.params;
    const userId = req.user.id;

    // V√©rifier que l'objet existe
    const ObjectModel = require('../models/Object');
    const object = await ObjectModel.findById(objectId).populate('owner', 'pseudo');
    
    if (!object) {
      return res.status(404).json({ error: 'Objet non trouv√©' });
    }

    // Ne pas permettre d'ajouter ses propres objets en favoris
    if (object.owner._id.toString() === userId) {
      return res.status(400).json({ error: 'Vous ne pouvez pas ajouter vos propres objets en favoris' });
    }

    const user = await User.findById(userId);
    const isFavorite = user.favoriteObjects && user.favoriteObjects.includes(objectId);

    let updatedUser;
    let action;

    if (isFavorite) {
      // Retirer des favoris
      updatedUser = await User.findByIdAndUpdate(
        userId,
        { $pull: { favoriteObjects: objectId } },
        { new: true }
      );
      action = 'removed';
    } else {
      // Ajouter aux favoris
      updatedUser = await User.findByIdAndUpdate(
        userId,
        { $addToSet: { favoriteObjects: objectId } }, // $addToSet √©vite les doublons
        { new: true }
      );
      action = 'added';

      // üîî D√âCLENCHER NOTIFICATION AU PROPRI√âTAIRE
      try {
        const { notificationTriggers } = require('../middleware/notificationTriggers');
        await notificationTriggers.triggerObjectInterest(
          object.owner._id,        // Propri√©taire (receveur)
          objectId,               // ID de l'objet
          object.title,           // Nom de l'objet
          userId,                 // ID de celui qui ajoute en favori
          req.user.pseudo,        // Nom de celui qui ajoute
          'favorite'              // Type d'int√©r√™t
        );
        console.log(`üîî Notification envoy√©e: ${req.user.pseudo} a ajout√© "${object.title}" en favori`);
      } catch (notifError) {
        console.error('‚ùå Erreur notification favoris:', notifError);
        // Ne pas faire √©chouer la requ√™te pour une erreur de notification
      }
    }

    res.json({
      success: true,
      action,
      isFavorite: action === 'added',
      favoriteCount: updatedUser.favoriteObjects ? updatedUser.favoriteObjects.length : 0
    });

  } catch (error) {
    console.error('‚ùå Erreur gestion favoris objet:', error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

/**
 * GET /api/users/me/favorite-objects
 * R√©cup√©rer les objets favoris d'un utilisateur
 */
router.get('/me/favorite-objects', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .populate({
        path: 'favoriteObjects',
        populate: {
          path: 'owner category',
          select: 'pseudo name city'
        }
      })
      .select('favoriteObjects');

    res.json({ 
      favoriteObjects: user.favoriteObjects || [],
      count: user.favoriteObjects ? user.favoriteObjects.length : 0
    });

  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration objets favoris:', error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// Changement de mot de passe s√©curis√©
router.post('/change-password', auth, async (req, res) => {
  const { currentPassword, password } = req.body;

  // V√©rification que les champs requis sont pr√©sents
  if (!currentPassword || !password) {
    return res.status(400).json({ message: 'Les champs currentPassword et password sont requis.' });
  }

  // V√©rification de la force du mot de passe (au moins 8 caract√®res, une lettre et un chiffre)
  if (!/^(?=.*[A-Za-z])(?=.*\d).{8,}$/.test(password)) {
    return res.status(400).json({ message: 'Le mot de passe doit contenir au moins 8 caract√®res, dont une lettre et un chiffre.' });
  }
  try {
    const user = await User.findById(req.user.id);
    if (!user) {
    const hashed = await bcrypt.hash(password, 12);
    }
    const isMatch = await bcrypt.compare(currentPassword, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: "Mot de passe actuel incorrect." });
    }
    const hashed = await bcrypt.hash(password, 10);
    await User.findByIdAndUpdate(req.user.id, { password: hashed });
    res.json({ message: 'Mot de passe chang√© avec succ√®s.' });
  } catch (err) {
    res.status(500).json({ message: "Erreur serveur lors du changement de mot de passe." });
  }
});

// R√©cup√©rer les objets d'un utilisateur (pour la vitrine publique)
router.get('/:userId/objects', auth, async (req, res) => {
  try {
    const ObjectModel = require('../models/Object');
    const { userId } = req.params;

    console.log('üîß [DEBUG] R√©cup√©ration objets pour userId:', userId);

    // Validation du userId
    if (!userId || userId === 'undefined' || userId === 'null') {
      return res.status(400).json({ message: "ID utilisateur manquant ou invalide." });
    }

    // V√©rifier que l'ID est un ObjectId valide
    const mongoose = require('mongoose');
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return res.status(400).json({ message: "ID utilisateur invalide." });
    }

    const objects = await ObjectModel.find({ 
      owner: userId, 
      status: 'available' // Seulement les objets disponibles
    })
    .populate('owner', 'pseudo city')
    .sort({ createdAt: -1 });

    console.log('‚úÖ [DEBUG] Objets trouv√©s:', objects.length);
    res.json(objects);
  } catch (err) {
    console.error('Erreur lors de la r√©cup√©ration des objets:', err);
    res.status(500).json({ message: "Erreur serveur lors de la r√©cup√©ration des objets." });
  }
});

/**
 * DELETE /me/account
 * Suppression CASCADE compl√®te du compte utilisateur (CONFORMIT√â RGPD)
 * Supprime TOUTES les donn√©es utilisateur de l'application
 */
router.delete('/me/account', auth, async (req, res) => {
  try {
    const { password, reason = 'Demande de l\'utilisateur' } = req.body;
    
    console.log(`üóëÔ∏è [DELETE ACCOUNT] Demande de suppression CASCADE pour l'utilisateur ${req.user.id}`);
    
    // R√©cup√©rer l'utilisateur
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        error: 'Utilisateur non trouv√©' 
      });
    }
    
    // V√©rifier le mot de passe pour s√©curit√©
    if (!password) {
      return res.status(400).json({ 
        success: false, 
        error: 'Mot de passe requis pour la suppression du compte' 
      });
    }
    
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      console.log(`‚ùå [DELETE ACCOUNT] Mot de passe incorrect pour ${user.email}`);
      return res.status(400).json({ 
        success: false, 
        error: 'Mot de passe incorrect' 
      });
    }
    
    // Emp√™cher la suppression des comptes admin (s√©curit√©)
    if (user.isAdmin || ['admin', 'super_admin', 'moderator'].includes(user.role)) {
      console.log(`üö´ [DELETE ACCOUNT] Tentative de suppression d'un compte admin: ${user.email}`);
      return res.status(403).json({ 
        success: false, 
        error: 'Les comptes administrateurs ne peuvent pas √™tre supprim√©s. Contactez un super administrateur.' 
      });
    }
    
    // üßπ D√âBUT DE LA SUPPRESSION CASCADE COMPL√àTE (CONFORMIT√â RGPD)
    console.log(`üßπ [RGPD CASCADE] D√©but de suppression cascade pour:`, {
      id: user._id,
      email: user.email,
      pseudo: user.pseudo,
      reason: reason,
      timestamp: new Date().toISOString()
    });

    const userId = req.user.id;
    let deletionStats = {
      user: 0,
      objects: 0,
      trades: 0,
      messages: 0,
      notifications: 0,
      securityLogs: 0,
      paymentMethods: 0,
      advertisements: 0
    };

    // 1. üì¶ Supprimer tous les objets de l'utilisateur
    try {
      const deletedObjects = await ObjectModel.deleteMany({ owner: userId });
      deletionStats.objects = deletedObjects.deletedCount;
      console.log(`   ‚úÖ [CASCADE] ${deletedObjects.deletedCount} objets supprim√©s`);
    } catch (err) {
      console.log(`   ‚ö†Ô∏è [CASCADE] Erreur objets:`, err.message);
    }

    // 2. ü§ù Supprimer tous les √©changes (en tant que fromUser ou toUser)
    try {
      const deletedTrades = await Trade.deleteMany({
        $or: [
          { fromUser: userId },
          { toUser: userId }
        ]
      });
      deletionStats.trades = deletedTrades.deletedCount;
      console.log(`   ‚úÖ [CASCADE] ${deletedTrades.deletedCount} √©changes supprim√©s`);
    } catch (err) {
      console.log(`   ‚ö†Ô∏è [CASCADE] Erreur trades:`, err.message);
    }

    // 3. üí¨ Supprimer tous les messages de l'utilisateur
    try {
      const deletedMessages = await Message.deleteMany({ from: userId });
      deletionStats.messages = deletedMessages.deletedCount;
      console.log(`   ‚úÖ [CASCADE] ${deletedMessages.deletedCount} messages supprim√©s`);
    } catch (err) {
      console.log(`   ‚ö†Ô∏è [CASCADE] Erreur messages:`, err.message);
    }

    // 4. üîî Supprimer toutes les notifications de l'utilisateur
    try {
      const deletedNotifications = await Notification.deleteMany({ user: userId });
      deletionStats.notifications = deletedNotifications.deletedCount;
      console.log(`   ‚úÖ [CASCADE] ${deletedNotifications.deletedCount} notifications supprim√©es`);
    } catch (err) {
      console.log(`   ‚ö†Ô∏è [CASCADE] Erreur notifications:`, err.message);
    }

    // 5. üîí Supprimer tous les logs de s√©curit√© de l'utilisateur
    try {
      const deletedSecurityLogs = await SecurityLog.deleteMany({ userId: userId });
      deletionStats.securityLogs = deletedSecurityLogs.deletedCount;
      console.log(`   ‚úÖ [CASCADE] ${deletedSecurityLogs.deletedCount} logs de s√©curit√© supprim√©s`);
    } catch (err) {
      console.log(`   ‚ö†Ô∏è [CASCADE] Erreur security logs:`, err.message);
    }

    // 6. üí≥ Supprimer toutes les m√©thodes de paiement
    try {
      const deletedPaymentMethods = await PaymentMethod.deleteMany({ userId: userId });
      deletionStats.paymentMethods = deletedPaymentMethods.deletedCount;
      console.log(`   ‚úÖ [CASCADE] ${deletedPaymentMethods.deletedCount} m√©thodes de paiement supprim√©es`);
    } catch (err) {
      console.log(`   ‚ö†Ô∏è [CASCADE] Erreur payment methods:`, err.message);
    }

    // 7. üì¢ Supprimer toutes les publicit√©s de l'utilisateur
    try {
      const deletedAdvertisements = await Advertisement.deleteMany({ user: userId });
      deletionStats.advertisements = deletedAdvertisements.deletedCount;
      console.log(`   ‚úÖ [CASCADE] ${deletedAdvertisements.deletedCount} publicit√©s supprim√©es`);
    } catch (err) {
      console.log(`   ‚ö†Ô∏è [CASCADE] Erreur advertisements:`, err.message);
    }

    // 8. üë§ Enfin, supprimer l'utilisateur lui-m√™me
    await User.findByIdAndDelete(userId);
    deletionStats.user = 1;
    console.log(`   ‚úÖ [CASCADE] Compte utilisateur supprim√©`);

    const totalDeleted = Object.values(deletionStats).reduce((sum, count) => sum + count, 0);

    console.log(`üéØ [RGPD CASCADE] Suppression termin√©e pour ${user.email}`);
    console.log(`üìä [RGPD CASCADE] STATISTIQUES:`, deletionStats, `(Total: ${totalDeleted} √©l√©ments)`);
    console.log(`üîí [RGPD CONFORMIT√â] Toutes les donn√©es utilisateur ont √©t√© d√©finitivement supprim√©es`);

    res.json({
      success: true,
      message: 'Votre compte et TOUTES vos donn√©es ont √©t√© supprim√©s d√©finitivement (conformit√© RGPD compl√®te)',
      deletionStats,
      totalDeleted,
      rgpdCompliant: true,
      deletedAt: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå [DELETE ACCOUNT CASCADE] Erreur lors de la suppression:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur serveur lors de la suppression CASCADE du compte' 
    });
  }
});

/**
 * POST /me/account/deactivate
 * D√©sactivation temporaire du compte (alternative √† la suppression)
 */
router.post('/me/account/deactivate', auth, async (req, res) => {
  try {
    const { password, reason = 'D√©sactivation volontaire' } = req.body;
    
    console.log(`‚è∏Ô∏è [DEACTIVATE ACCOUNT] Demande de d√©sactivation pour l'utilisateur ${req.user.id}`);
    
    // R√©cup√©rer l'utilisateur
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        error: 'Utilisateur non trouv√©' 
      });
    }
    
    // V√©rifier le mot de passe
    if (!password) {
      return res.status(400).json({ 
        success: false, 
        error: 'Mot de passe requis pour la d√©sactivation du compte' 
      });
    }
    
    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(400).json({ 
        success: false, 
        error: 'Mot de passe incorrect' 
      });
    }
    
    // Emp√™cher la d√©sactivation des comptes admin
    if (user.isAdmin || ['admin', 'super_admin', 'moderator'].includes(user.role)) {
      return res.status(403).json({ 
        success: false, 
        error: 'Les comptes administrateurs ne peuvent pas √™tre d√©sactiv√©s.' 
      });
    }
    
    // D√©sactiver le compte
    const updatedUser = await User.findByIdAndUpdate(req.user.id, {
      status: 'inactive',
      deactivatedAt: new Date(),
      deactivationReason: reason,
      adminNotes: `${user.adminNotes || ''}\n[${new Date().toISOString()}] D√âSACTIV√â par l'utilisateur: ${reason}`
    }, { new: true });
    
    console.log(`‚è∏Ô∏è [DEACTIVATE ACCOUNT] Compte d√©sactiv√©: ${user.email}`);
    
    res.json({
      success: true,
      message: 'Votre compte a √©t√© d√©sactiv√©. Vous pouvez le r√©activer en vous reconnectant.',
      status: updatedUser.status,
      deactivatedAt: updatedUser.deactivatedAt
    });
    
  } catch (error) {
    console.error('‚ùå [DEACTIVATE ACCOUNT] Erreur lors de la d√©sactivation:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur serveur lors de la d√©sactivation du compte' 
    });
  }
});

// GET /:id/reviews - R√©cup√©rer tous les avis re√ßus par un utilisateur
router.get('/:id/reviews', async (req, res) => {
  try {
    const userId = req.params.id;
    
    // V√©rifier que l'utilisateur existe
    const user = await User.findById(userId).select('pseudo averageRating totalRatings');
    if (!user) {
      return res.status(404).json({ 
        success: false, 
        message: 'Utilisateur non trouv√©.' 
      });
    }

    // R√©cup√©rer les avis depuis les trocs termin√©s
    const Trade = require('../models/Trade');
    const trades = await Trade.find({
      $and: [
        { status: 'completed' },
        {
          $or: [
            { 'requester': userId, 'ratings.toUserRating': { $exists: true } },
            { 'owner': userId, 'ratings.fromUserRating': { $exists: true } }
          ]
        }
      ]
    }).populate('requester', 'pseudo avatar')
      .populate('owner', 'pseudo avatar')
      .populate('requestedObjects', 'title')
      .sort({ completedAt: -1 });

    // Formatter les avis pour cet utilisateur
    const reviews = [];
    
    trades.forEach(trade => {
      if (trade.requester._id.toString() === userId && trade.ratings?.toUserRating) {
        // L'utilisateur √©tait le requester et a re√ßu une √©valuation
        reviews.push({
          rating: trade.ratings.toUserRating.score,
          comment: trade.ratings.toUserRating.comment,
          submittedAt: trade.ratings.toUserRating.submittedAt,
          fromUser: {
            id: trade.owner._id,
            pseudo: trade.owner.pseudo,
            avatar: trade.owner.avatar
          },
          tradeTitle: trade.requestedObjects?.[0]?.title || 'Troc',
          tradeId: trade._id
        });
      }
      
      if (trade.owner._id.toString() === userId && trade.ratings?.fromUserRating) {
        // L'utilisateur √©tait l'owner et a re√ßu une √©valuation
        reviews.push({
          rating: trade.ratings.fromUserRating.score,
          comment: trade.ratings.fromUserRating.comment,
          submittedAt: trade.ratings.fromUserRating.submittedAt,
          fromUser: {
            id: trade.requester._id,
            pseudo: trade.requester.pseudo,
            avatar: trade.requester.avatar
          },
          tradeTitle: trade.requestedObjects?.[0]?.title || 'Troc',
          tradeId: trade._id
        });
      }
    });

    res.json({
      success: true,
      user: {
        id: user._id,
        pseudo: user.pseudo,
        averageRating: user.averageRating,
        totalRatings: user.totalRatings
      },
      reviews: reviews
    });

  } catch (err) {
    console.error('Erreur r√©cup√©ration avis:', err);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur serveur lors de la r√©cup√©ration des avis.' 
    });
  }
});

// Route de d√©veloppement pour r√©cup√©rer les codes de v√©rification (SANS AUTH)
router.get('/dev/verification-codes', async (req, res) => {
  try {
    console.log('üîß [DEV] R√©cup√©ration des codes de v√©rification');
    console.log('üîß [DEV] NODE_ENV:', process.env.NODE_ENV);
    
    const users = await User.find({ 
      emailVerificationToken: { $exists: true, $ne: null } 
    }).select('email pseudo emailVerificationToken emailVerified');

    const codes = users.map(user => ({
      email: user.email,
      pseudo: user.pseudo,
      emailVerified: user.emailVerified,
      verificationCode: user.emailVerificationToken ? user.emailVerificationToken.slice(-6) : null,
      fullToken: user.emailVerificationToken
    }));

    console.log(`üîß [DEV] ${codes.length} codes trouv√©s`);
    res.json({ codes });
  } catch (error) {
    console.error('‚ùå [DEV] Erreur r√©cup√©ration codes:', error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// Route de d√©veloppement pour r√©cup√©rer le code d'un utilisateur sp√©cifique
router.get('/dev/verification-code/:email', async (req, res) => {
  try {
    const { email } = req.params;
    console.log('üîß [DEV] R√©cup√©ration code pour:', email);
    console.log('üîß [DEV] NODE_ENV:', process.env.NODE_ENV);

    const user = await User.findOne({ email }).select('email pseudo emailVerificationToken emailVerified');
    
    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    const code = user.emailVerificationToken ? user.emailVerificationToken.slice(-6) : null;
    
    console.log(`üîß [DEV] Code trouv√© pour ${email}: ${code}`);
    res.json({
      email: user.email,
      pseudo: user.pseudo,
      emailVerified: user.emailVerified,
      verificationCode: code,
      fullToken: user.emailVerificationToken
    });
  } catch (error) {
    console.error('‚ùå [DEV] Erreur r√©cup√©ration code:', error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// Route de d√©veloppement pour r√©cup√©rer les codes de v√©rification SMS
router.get('/dev/sms-verification-codes', async (req, res) => {
  try {
    console.log('üîß [DEV] R√©cup√©ration des codes de v√©rification SMS');
    console.log('üîß [DEV] NODE_ENV:', process.env.NODE_ENV);
    
    const users = await User.find({ 
      phoneVerificationCode: { $exists: true, $ne: null } 
    }).select('email pseudo phoneNumber phoneVerificationCode phoneVerified phoneVerificationExpires');

    const codes = users.map(user => ({
      email: user.email,
      pseudo: user.pseudo,
      phoneNumber: user.phoneNumber,
      phoneVerified: user.phoneVerified,
      smsVerificationCode: user.phoneVerificationCode,
      expiresAt: user.phoneVerificationExpires
    }));

    console.log(`üîß [DEV] ${codes.length} codes SMS trouv√©s`);
    res.json({ codes });
  } catch (error) {
    console.error('‚ùå [DEV] Erreur r√©cup√©ration codes SMS:', error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// Route de d√©veloppement pour r√©cup√©rer le code SMS d'un utilisateur sp√©cifique
router.get('/dev/sms-verification-code/:email', async (req, res) => {
  try {
    const { email } = req.params;
    console.log('üîß [DEV] R√©cup√©ration code SMS pour:', email);
    console.log('üîß [DEV] NODE_ENV:', process.env.NODE_ENV);

    const user = await User.findOne({ email }).select('email pseudo phoneNumber phoneVerificationCode phoneVerified phoneVerificationExpires');
    
    if (!user) {
      return res.status(404).json({ error: 'Utilisateur non trouv√©' });
    }

    console.log(`üîß [DEV] Code SMS trouv√© pour ${email}: ${user.phoneVerificationCode}`);
    res.json({
      email: user.email,
      pseudo: user.pseudo,
      phoneNumber: user.phoneNumber,
      phoneVerified: user.phoneVerified,
      smsVerificationCode: user.phoneVerificationCode,
      expiresAt: user.phoneVerificationExpires
    });
  } catch (error) {
    console.error('‚ùå [DEV] Erreur r√©cup√©ration code SMS:', error);
    res.status(500).json({ error: 'Erreur serveur' });
  }
});

// üì± GESTION TOKEN PUSH NOTIFICATIONS
router.post('/push-token', auth, async (req, res) => {
  try {
    const { pushToken } = req.body;
    
    if (!pushToken) {
      return res.status(400).json({ message: 'Token push requis' });
    }

    // Mettre √† jour le token push de l'utilisateur
    await User.findByIdAndUpdate(req.user.id, {
      pushToken: pushToken,
      pushTokenUpdatedAt: new Date()
    });

    console.log(`üì± Token push enregistr√© pour ${req.user.email}: ${pushToken.substring(0, 20)}...`);
    
    res.json({ 
      success: true, 
      message: 'Token push enregistr√© avec succ√®s' 
    });
  } catch (error) {
    console.error('‚ùå Erreur enregistrement token push:', error);
    res.status(500).json({ message: 'Erreur serveur' });
  }
});

module.exports = router;