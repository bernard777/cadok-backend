/**
 * üì± Tests E2E - Interfaces Mobile Admin et Gamification
 * Tests d'int√©gration entre le backend et les nouvelles interfaces mobile
 */

const request = require('supertest');
const { MongoClient } = require('mongodb');
const app = require('../../app');

// Configuration Jest
jest.setTimeout(30000);

describe('üì± Interfaces Mobile - Tests E2E Int√©gration', () => {
  let mongoClient;
  let db;
  let adminToken;
  let userToken;
  let testAdmin;
  let testUser;

  // Setup global
  beforeAll(async () => {
    try {
      console.log('üì± Initialisation tests interfaces mobile...');
      
      // Connexion MongoDB
      const mongoUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/cadok_test';
      mongoClient = new MongoClient(mongoUri);
      await mongoClient.connect();
      const dbName = mongoUri.split('/').pop().split('?')[0];
      db = mongoClient.db(dbName);
      
      // Nettoyage initial
      await db.collection('users').deleteMany({});
      await db.collection('events').deleteMany({});
      await db.collection('objects').deleteMany({});
      
      // Cr√©ation des utilisateurs de test
      await createTestUsers();
      
      console.log('‚úÖ Setup interfaces mobile termin√©');
    } catch (error) {
      console.error('‚ùå Erreur setup:', error);
      throw error;
    }
  });

  // Nettoyage final
  afterAll(async () => {
    if (mongoClient) {
      await mongoClient.close();
    }
  });

  /**
   * üèóÔ∏è Cr√©ation des utilisateurs de test
   */
  async function createTestUsers() {
    // Admin
    const adminSignupResponse = await request(app)
      .post('/api/auth/signup')
      .send({
        pseudo: 'MobileAdmin',
        email: 'mobileadmin@cadok.fr',
        password: 'MobileAdmin123!'
      });
    
    expect(adminSignupResponse.status).toBe(201);
    
    const adminLoginResponse = await request(app)
      .post('/api/auth/signin')
      .send({
        email: 'mobileadmin@cadok.fr',
        password: 'MobileAdmin123!'
      });
    
    expect(adminLoginResponse.status).toBe(200);
    adminToken = adminLoginResponse.body.token;
    testAdmin = adminLoginResponse.body.user;
    
    // Utilisateur normal
    const userSignupResponse = await request(app)
      .post('/api/auth/signup')
      .send({
        pseudo: 'MobileUser',
        email: 'mobileuser@cadok.fr',
        password: 'MobileUser123!'
      });
    
    expect(userSignupResponse.status).toBe(201);
    
    const userLoginResponse = await request(app)
      .post('/api/auth/signin')
      .send({
        email: 'mobileuser@cadok.fr',
        password: 'MobileUser123!'
      });
    
    expect(userLoginResponse.status).toBe(200);
    userToken = userLoginResponse.body.token;
    testUser = userLoginResponse.body.user;
    
    // Promouvoir l'admin
    await db.collection('users').updateOne(
      { _id: require('mongodb').ObjectId(testAdmin._id) },
      {
        $set: {
          role: 'admin',
          isAdmin: true,
          adminPermissions: {
            users: true,
            events: true,
            analytics: true,
            system: false
          }
        }
      }
    );
  }

  // =============================================================================
  // üèõÔ∏è TESTS INTERFACE ADMIN MOBILE
  // =============================================================================

  describe('üèõÔ∏è Interface Admin Mobile (AdminScreen)', () => {
    
    test('Donn√©es dashboard admin compl√®tes pour mobile', async () => {
      const response = await request(app)
        .get('/api/admin/dashboard')
        .set('Authorization', `Bearer ${adminToken}`);
      
      // Si l'endpoint n'existe pas encore, on teste les composants individuels
      if (response.status === 404) {
        // Tester les statistiques utilisateurs
        const usersStatsResponse = await request(app)
          .get('/api/admin/users/stats')
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(usersStatsResponse.status).toBe(200);
        expect(usersStatsResponse.body.success).toBe(true);
        expect(usersStatsResponse.body.stats).toHaveProperty('totalUsers');
        
        // Tester les √©v√©nements pour l'admin
        const eventsResponse = await request(app)
          .get('/api/admin/events')
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(eventsResponse.status).toBe(200);
        expect(eventsResponse.body.success).toBe(true);
      } else {
        expect(response.status).toBe(200);
        expect(response.body.success).toBe(true);
        
        const dashboard = response.body.dashboard;
        expect(dashboard).toHaveProperty('userStats');
        expect(dashboard).toHaveProperty('eventStats');
        expect(dashboard).toHaveProperty('systemHealth');
      }
    });
    
    test('Menu admin accessible selon permissions', async () => {
      // V√©rifier les permissions de l'admin
      const response = await request(app)
        .get('/api/admin/permissions')
        .set('Authorization', `Bearer ${adminToken}`);
      
      if (response.status === 404) {
        // Tester indirectement via l'acc√®s aux routes
        const usersAccess = await request(app)
          .get('/api/admin/users')
          .set('Authorization', `Bearer ${adminToken}`);
        
        const eventsAccess = await request(app)
          .get('/api/admin/events')
          .set('Authorization', `Bearer ${adminToken}`);
        
        expect(usersAccess.status).toBe(200);
        expect(eventsAccess.status).toBe(200);
      } else {
        expect(response.status).toBe(200);
        expect(response.body.permissions.users).toBe(true);
        expect(response.body.permissions.events).toBe(true);
      }
    });
    
    test('Statistiques syst√®me pour interface admin', async () => {
      // Cr√©er quelques donn√©es de test
      await request(app)
        .post('/api/objects')
        .set('Authorization', `Bearer ${userToken}`)
        .send({
          name: 'Test Object Admin Stats',
          description: 'Objet pour test stats admin',
          category: 'Test',
          condition: 'Bon √©tat',
          estimatedValue: 15,
          images: []
        });
      
      const statsResponse = await request(app)
        .get('/api/admin/users/stats')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(statsResponse.status).toBe(200);
      expect(statsResponse.body.stats.totalUsers).toBeGreaterThanOrEqual(2);
    });
  });

  // =============================================================================
  // üé™ TESTS INTERFACE √âV√âNEMENTS ADMIN
  // =============================================================================

  describe('üé™ Interface √âv√©nements Admin (AdminEventsScreen)', () => {
    let createdEventId;
    
    test('Cr√©ation d\'√©v√©nement via interface mobile', async () => {
      const eventData = {
        name: '√âv√©nement Mobile Test',
        description: 'Cr√©√© via l\'interface mobile admin',
        startDate: new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString(), // Dans 2 heures
        endDate: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000).toISOString(), // Dans 5 jours
        theme: 'seasonal',
        bonusMultiplier: 1.3,
        challenges: [
          {
            title: 'Challenge Mobile Test',
            description: 'D√©fi cr√©√© via interface mobile',
            type: 'create_objects',
            target: 3,
            reward: { points: 100 }
          }
        ]
      };
      
      const response = await request(app)
        .post('/api/admin/events')
        .set('Authorization', `Bearer ${adminToken}`)
        .send(eventData);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.event.name).toBe(eventData.name);
      
      createdEventId = response.body.event._id;
    });
    
    test('Templates d\'√©v√©nement pour interface mobile', async () => {
      const response = await request(app)
        .get('/api/admin/events/templates')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.templates).toBeInstanceOf(Array);
      expect(response.body.templates.length).toBeGreaterThan(0);
      
      // V√©rifier format adapt√© mobile
      const template = response.body.templates[0];
      expect(template).toHaveProperty('id');
      expect(template).toHaveProperty('name');
      expect(template).toHaveProperty('icon');
      expect(template).toHaveProperty('duration');
    });
    
    test('Cr√©ation d\'√©v√©nement depuis template', async () => {
      const templatesResponse = await request(app)
        .get('/api/admin/events/templates')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(templatesResponse.status).toBe(200);
      const template = templatesResponse.body.templates[0];
      
      const response = await request(app)
        .post(`/api/admin/events/templates/${template.id}/create`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          customName: 'Template Test Mobile',
          startDate: new Date(Date.now() + 60 * 60 * 1000).toISOString(),
          customizations: {
            bonusMultiplier: 2.0,
            additionalReward: { points: 50 }
          }
        });
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
    });
    
    test('Gestion des √©v√©nements (activation/d√©sactivation)', async () => {
      if (!createdEventId) {
        console.log('‚ö†Ô∏è Pas d\'√©v√©nement cr√©√©, skip du test');
        return;
      }
      
      // D√©sactivation
      const deactivateResponse = await request(app)
        .post(`/api/admin/events/${createdEventId}/activate`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ active: false });
      
      expect(deactivateResponse.status).toBe(200);
      expect(deactivateResponse.body.success).toBe(true);
      
      // R√©activation
      const reactivateResponse = await request(app)
        .post(`/api/admin/events/${createdEventId}/activate`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({ active: true });
      
      expect(reactivateResponse.status).toBe(200);
      expect(reactivateResponse.body.success).toBe(true);
    });
    
    test('Analytics √©v√©nement pour interface mobile', async () => {
      if (!createdEventId) {
        console.log('‚ö†Ô∏è Pas d\'√©v√©nement cr√©√©, skip du test');
        return;
      }
      
      const response = await request(app)
        .get(`/api/admin/events/${createdEventId}/analytics`)
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.analytics).toHaveProperty('participation');
      expect(response.body.analytics).toHaveProperty('challengesCompletion');
    });
  });

  // =============================================================================
  // üéÆ TESTS INTERFACE GAMIFICATION UTILISATEUR
  // =============================================================================

  describe('üéÆ Interface Gamification Utilisateur (GamificationScreen)', () => {
    
    test('Dashboard gamification complet pour mobile', async () => {
      const response = await request(app)
        .get('/api/gamification/mobile-dashboard')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      
      const dashboard = response.body.dashboard;
      expect(dashboard).toHaveProperty('userStats');
      expect(dashboard).toHaveProperty('recentBadges');
      expect(dashboard).toHaveProperty('activeChallenges');
      expect(dashboard).toHaveProperty('activeEvents');
      
      // Format optimis√© pour React Native
      expect(dashboard.userStats).toHaveProperty('level');
      expect(dashboard.userStats).toHaveProperty('totalPoints');
      expect(dashboard.userStats).toHaveProperty('progressToNextLevel');
    });
    
    test('Liste des badges avec progression', async () => {
      const response = await request(app)
        .get('/api/gamification/user-badges')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.badges).toBeInstanceOf(Array);
      
      // Chaque badge doit avoir les infos pour l'affichage mobile
      if (response.body.badges.length > 0) {
        const badge = response.body.badges[0];
        expect(badge.badge).toHaveProperty('icon');
        expect(badge.badge).toHaveProperty('name');
        expect(badge.badge).toHaveProperty('description');
        expect(badge).toHaveProperty('earnedAt');
      }
    });
    
    test('D√©fis actifs avec progression en temps r√©el', async () => {
      const response = await request(app)
        .get('/api/gamification/challenges/active')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.challenges).toBeInstanceOf(Array);
      
      // Cr√©er un objet pour tester la progression
      await request(app)
        .post('/api/objects')
        .set('Authorization', `Bearer ${userToken}`)
        .send({
          name: 'Test Progression Challenge',
          description: 'Objet pour tester progression',
          category: 'Test',
          condition: 'Bon √©tat',
          estimatedValue: 12,
          images: []
        });
      
      // V√©rifier la progression mise √† jour
      const progressResponse = await request(app)
        .get('/api/gamification/challenges/progress')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(progressResponse.status).toBe(200);
      expect(progressResponse.body.success).toBe(true);
    });
    
    test('Classement optimis√© pour mobile', async () => {
      const response = await request(app)
        .get('/api/gamification/leaderboard')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.leaderboard).toBeInstanceOf(Array);
      
      if (response.body.leaderboard.length > 0) {
        const user = response.body.leaderboard[0];
        expect(user).toHaveProperty('pseudo');
        expect(user).toHaveProperty('level');
        expect(user).toHaveProperty('totalPoints');
        expect(user).toHaveProperty('rank');
        // Pas d'infos sensibles expos√©es
        expect(user).not.toHaveProperty('email');
        expect(user).not.toHaveProperty('_id');
      }
    });
  });

  // =============================================================================
  // üèÜ TESTS INTERFACE ACHIEVEMENTS/BADGES
  // =============================================================================

  describe('üèÜ Interface Achievements/Badges (BadgesScreen)', () => {
    
    test('Catalogue complet des badges disponibles', async () => {
      const response = await request(app)
        .get('/api/gamification/badges')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.badges).toBeInstanceOf(Array);
      expect(response.body.badges.length).toBeGreaterThan(0);
      
      // V√©rifier la structure pour l'interface mobile
      const badge = response.body.badges[0];
      expect(badge).toHaveProperty('id');
      expect(badge).toHaveProperty('name');
      expect(badge).toHaveProperty('description');
      expect(badge).toHaveProperty('icon');
      expect(badge).toHaveProperty('rarity');
      expect(badge).toHaveProperty('criteria');
    });
    
    test('Badges obtenus avec d√©tails de progression', async () => {
      // Cr√©er quelques objets pour d√©clencher des badges
      for (let i = 1; i <= 3; i++) {
        await request(app)
          .post('/api/objects')
          .set('Authorization', `Bearer ${userToken}`)
          .send({
            name: `Badge Test Object ${i}`,
            description: `Objet ${i} pour tester badges`,
            category: 'Test',
            condition: 'Excellent',
            estimatedValue: 20,
            images: []
          });
      }
      
      const response = await request(app)
        .get('/api/gamification/user-badges')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.badges.length).toBeGreaterThan(0);
      
      // V√©rifier qu'au moins le badge "Bienvenue" et "Premier objet" sont pr√©sents
      const welcomeBadge = response.body.badges.find(b => b.badge.id === 'welcome');
      const firstObjectBadge = response.body.badges.find(b => b.badge.id === 'first_object');
      
      expect(welcomeBadge).toBeDefined();
      expect(firstObjectBadge).toBeDefined();
    });
    
    test('Progression vers badges non obtenus', async () => {
      const response = await request(app)
        .get('/api/gamification/badges/progress')
        .set('Authorization', `Bearer ${userToken}`);
      
      if (response.status === 200) {
        expect(response.body.success).toBe(true);
        expect(response.body.progress).toBeInstanceOf(Array);
        
        // Chaque progression doit avoir les infos n√©cessaires pour l'UI
        if (response.body.progress.length > 0) {
          const progress = response.body.progress[0];
          expect(progress).toHaveProperty('badgeId');
          expect(progress).toHaveProperty('currentValue');
          expect(progress).toHaveProperty('targetValue');
          expect(progress).toHaveProperty('percentage');
        }
      }
    });
  });

  // =============================================================================
  // üìä TESTS INTERFACE ANALYTICS UTILISATEUR
  // =============================================================================

  describe('üìä Interface Analytics Utilisateur (AnalyticsScreen)', () => {
    
    test('Statistiques personnelles compl√®tes', async () => {
      const response = await request(app)
        .get('/api/gamification/user-stats')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      
      const stats = response.body.stats;
      expect(stats).toHaveProperty('totalPoints');
      expect(stats).toHaveProperty('level');
      expect(stats).toHaveProperty('nextLevelPoints');
      expect(stats).toHaveProperty('badgesCount');
      expect(stats).toHaveProperty('challengesCompleted');
      expect(stats).toHaveProperty('objectsCreated');
      expect(stats).toHaveProperty('tradesCompleted');
      expect(stats).toHaveProperty('registrationDate');
    });
    
    test('Historique d\'activit√© pour graphiques', async () => {
      const response = await request(app)
        .get('/api/gamification/user-activity')
        .set('Authorization', `Bearer ${userToken}`);
      
      if (response.status === 200) {
        expect(response.body.success).toBe(true);
        expect(response.body.activity).toBeInstanceOf(Array);
        
        // Format pour graphiques mobile
        if (response.body.activity.length > 0) {
          const activity = response.body.activity[0];
          expect(activity).toHaveProperty('date');
          expect(activity).toHaveProperty('points');
          expect(activity).toHaveProperty('actions');
        }
      }
    });
    
    test('Comparaison avec autres utilisateurs', async () => {
      const response = await request(app)
        .get('/api/gamification/user-ranking')
        .set('Authorization', `Bearer ${userToken}`);
      
      if (response.status === 200) {
        expect(response.body.success).toBe(true);
        expect(response.body.ranking).toHaveProperty('currentRank');
        expect(response.body.ranking).toHaveProperty('totalUsers');
        expect(response.body.ranking).toHaveProperty('percentile');
      }
    });
  });

  // =============================================================================
  // üîÑ TESTS NAVIGATION ET UX MOBILE
  // =============================================================================

  describe('üîÑ Navigation et UX Mobile', () => {
    
    test('Transitions entre √©crans admin fonctionnelles', async () => {
      // Simuler navigation : Dashboard ‚Üí Gestion Utilisateurs
      const dashboardResponse = await request(app)
        .get('/api/admin/users/stats')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(dashboardResponse.status).toBe(200);
      
      // Navigation : Dashboard ‚Üí Gestion √âv√©nements
      const eventsResponse = await request(app)
        .get('/api/admin/events')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(eventsResponse.status).toBe(200);
    });
    
    test('Gestion des erreurs adapt√©e mobile', async () => {
      // Test avec token expir√©/invalide
      const response = await request(app)
        .get('/api/admin/users')
        .set('Authorization', 'Bearer token_invalide_mobile');
      
      expect(response.status).toBe(401);
      expect(response.body).toHaveProperty('error');
      
      // Format d'erreur adapt√© pour React Native
      expect(typeof response.body.error).toBe('string');
    });
    
    test('Performance des API pour UX mobile fluide', async () => {
      const startTime = Date.now();
      
      const promises = [
        request(app).get('/api/gamification/user-stats').set('Authorization', `Bearer ${userToken}`),
        request(app).get('/api/gamification/user-badges').set('Authorization', `Bearer ${userToken}`),
        request(app).get('/api/gamification/challenges/active').set('Authorization', `Bearer ${userToken}`)
      ];
      
      const results = await Promise.all(promises);
      const endTime = Date.now();
      
      // Toutes les requ√™tes doivent r√©ussir
      results.forEach(result => {
        expect(result.status).toBe(200);
      });
      
      // Temps de r√©ponse acceptable pour mobile
      const totalTime = endTime - startTime;
      expect(totalTime).toBeLessThan(3000); // Moins de 3 secondes
      
      console.log(`üì± Performance mobile: ${totalTime}ms pour 3 requ√™tes parall√®les`);
    });
  });

  // =============================================================================
  // ‚úÖ VALIDATION INT√âGRATION COMPL√àTE
  // =============================================================================

  describe('‚úÖ Validation Int√©gration Compl√®te', () => {
    
    test('Workflow complet utilisateur mobile', async () => {
      console.log('üîÑ Test workflow utilisateur mobile complet...');
      
      // 1. Consultation dashboard
      const dashboardResponse = await request(app)
        .get('/api/gamification/mobile-dashboard')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(dashboardResponse.status).toBe(200);
      
      // 2. Cr√©ation d'objet (action gamifi√©e)
      const objectResponse = await request(app)
        .post('/api/objects')
        .set('Authorization', `Bearer ${userToken}`)
        .send({
          name: 'Workflow Mobile Final',
          description: 'Test workflow complet mobile',
          category: 'Final Test',
          condition: 'Parfait',
          estimatedValue: 30,
          images: []
        });
      
      expect(objectResponse.status).toBe(201);
      
      // 3. V√©rification progression badges
      const badgesResponse = await request(app)
        .get('/api/gamification/user-badges')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(badgesResponse.status).toBe(200);
      
      // 4. Consultation statistiques mises √† jour
      const updatedStatsResponse = await request(app)
        .get('/api/gamification/user-stats')
        .set('Authorization', `Bearer ${userToken}`);
      
      expect(updatedStatsResponse.status).toBe(200);
      expect(updatedStatsResponse.body.stats.objectsCreated).toBeGreaterThan(0);
      
      console.log('‚úÖ Workflow utilisateur mobile complet valid√©');
    });
    
    test('Workflow complet admin mobile', async () => {
      console.log('üèõÔ∏è Test workflow admin mobile complet...');
      
      // 1. Consultation dashboard admin
      const statsResponse = await request(app)
        .get('/api/admin/users/stats')
        .set('Authorization', `Bearer ${adminToken}`);
      
      expect(statsResponse.status).toBe(200);
      
      // 2. Cr√©ation √©v√©nement
      const eventResponse = await request(app)
        .post('/api/admin/events')
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          name: 'Workflow Admin Final',
          description: '√âv√©nement cr√©√© dans workflow admin mobile',
          startDate: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
          endDate: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000).toISOString(),
          theme: 'test',
          bonusMultiplier: 1.0
        });
      
      expect(eventResponse.status).toBe(200);
      
      // 3. Gestion utilisateur (promotion test)
      const promoteResponse = await request(app)
        .post(`/api/admin/users/${testUser._id}/promote`)
        .set('Authorization', `Bearer ${adminToken}`)
        .send({
          role: 'moderator',
          permissions: { events: true },
          notes: 'Promotion test workflow admin mobile'
        });
      
      expect(promoteResponse.status).toBe(200);
      
      console.log('‚úÖ Workflow admin mobile complet valid√©');
    });
    
    test('Syst√®me compl√®tement op√©rationnel', async () => {
      // Health check global
      const healthResponse = await request(app).get('/health');
      expect(healthResponse.status).toBe(200);
      
      // V√©rification des donn√©es cr√©√©es
      const usersCount = await db.collection('users').countDocuments();
      const objectsCount = await db.collection('objects').countDocuments();
      const eventsCount = await db.collection('events').countDocuments();
      
      expect(usersCount).toBeGreaterThanOrEqual(2);
      expect(objectsCount).toBeGreaterThan(0);
      
      console.log(`üéâ Syst√®me complet valid√©:`);
      console.log(`   üë• ${usersCount} utilisateurs`);
      console.log(`   üì¶ ${objectsCount} objets`);
      console.log(`   üé™ ${eventsCount} √©v√©nements`);
      console.log(`‚úÖ Toutes les interfaces mobile sont fonctionnelles !`);
    });
  });
});
